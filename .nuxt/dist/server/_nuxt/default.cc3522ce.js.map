{"version":3,"file":"default.cc3522ce.js","sources":["../../../../components/babylon.vue","../../../../layouts/default.vue"],"sourcesContent":["<template>\n  <canvas id=\"babylon\" ref=\"bjsCanvas\" />\n</template>\n\n<style scoped>\n#babylon {\n  position: absolute;\n  top: 0;\n}\n</style>\n\n<script setup>\nimport {\n  Engine,\n  Scene,\n  HemisphericLight,\n  Vector3,\n  Color3,\n  Color4,\n  ArcRotateCamera,\n  Texture,\n  CubeTexture,\n  PBRMetallicRoughnessMaterial,\n  SceneLoader\n} from \"@babylonjs/core\";\n\n\nimport { OBJFileLoader } from 'babylonjs-loaders';\n\nSceneLoader.RegisterPlugin(new OBJFileLoader())\n\n\n// the variable name MUST match the ref value used in the html templte above\nconst bjsCanvas = ref(null);\nlet engine;\n// the canvas is accessible only when the component is already mounted\nonMounted(() => {\n  const BJS_CANVAS_WIDTH = window.innerWidth;\n  const BJS_CANVAS_HEIGHT = window.innerHeight;\n  const BJS_CANVAS_ZINDEX = \"-1\";\n  // you have to set the width on the canvas object\n  // setting the width and height using css or canvas.style\n  // only stretches the canvas to the desired dimensions\n  bjsCanvas.value.width = BJS_CANVAS_WIDTH;\n  bjsCanvas.value.height = BJS_CANVAS_HEIGHT;\n  bjsCanvas.value.style.zIndex = BJS_CANVAS_ZINDEX;\n  // do not forget to use the .value property on the ref object\n  // everywhere you need to access the HTMLCanvasElement\n  engine = new Engine(bjsCanvas.value);\n  const scene = new Scene(engine);\n  // create a scene\n  createScene(scene, bjsCanvas.value);\n  // the render loop is actually rendering the scene\n  setupRenderLoop(engine, scene);\n  window.addEventListener(\"resize\", onWindowResize);\n});\n\nconst onWindowResize = () => {\n  bjsCanvas.value.width = window.innerWidth;\n  bjsCanvas.value.height = window.innerHeight;\n  if (engine) engine.resize();\n};\n\nconst cleanup = () => {\n  window.removeEventListener(\"resize\", onWindowResize);\n};\n\nonUnmounted(() => {\n  cleanup();\n});\n\nconst setupRenderLoop = (engine, scene) => {\n  engine.runRenderLoop(() => {\n    scene.render();\n  });\n};\n\nconst createScene = (scene, canvas) => {\n  // setting up a basic scene\n  const camera = new ArcRotateCamera(\n    'Camera',\n    0.75,\n    1.25,\n    8,\n    Vector3.Zero(),\n    scene\n  );\n\n  camera.lowerRadiusLimit = 4;\n  camera.upperRadiusLimit = 15;\n  camera.attachControl(canvas, false);\n  camera.useAutoRotationBehavior = true;\n  scene.clearColor = new Color4(1, 1, 1, 1);\n\n  const light = new HemisphericLight(\n    'light',\n    new Vector3(1, 1, 0),\n    scene\n  );\n\n  light.intensity = 0.25;\n\n  const pbr = new PBRMetallicRoughnessMaterial('pbr', scene);\n\n  pbr.diffuseColor = new Color3(0, 0, 0, 0.73);\n  pbr.specularColor = new Color3(0.21, 0.21, 0.21, 0.83);\n  pbr.metallic = 0.8; // set to 1 to only use it from the metallicRoughnessTexture\n  pbr.roughness = 0.25; // set to 1 to only use it from the metallicRoughnessTexture\n  pbr.metallicRoughnessTexture = new Texture(\n    `https://raw.githubusercontent.com/0000rgb124/rgb124.github.io/main/cinema4d/texture/ROUGH_00000.jpg`,\n    scene\n  );\n\n  pbr.environmentTexture = CubeTexture.CreateFromPrefilteredData(\n    'https://raw.githubusercontent.com/0000rgb124/rgb124.github.io/main/cinema4d/texture/environment.env',\n    scene\n  );\n\n\n  const textureFiles = [];\n\n  for (let i = 0; i < 76; i++) {\n    textureFiles.push(\n      new Texture(\n        `texture/emissive/Emission_v2_000${i\n          .toString()\n          .padStart(2, '0')}.jpg`,\n        scene\n      )\n    );\n  }\n\n  let counter = 0;\n  let currentTexture = textureFiles[counter];\n\n  pbr.baseTexture = currentTexture;\n\n  const logo = SceneLoader.Append(\n    '',\n    'modelinglogo2.obj',\n    scene,\n    (scene) => {\n      scene.meshes.forEach((m) => {\n        m.material = pbr;\n      });\n    }\n  );\n\n  logo.material = pbr;\n\n\n  scene.clearColor = new BABYLON.Color3(1, 1, 1);\n\n  let iFrame = 0;\n\n  scene.registerBeforeRender(() => {\n    pbr.baseTexture = textureFiles[counter];\n    if (iFrame % 2 == 0) counter++;\n    iFrame++;\n    if (counter == 76) counter = 0;\n  });\n\n  scene.onPointerDown = (event, pickResult) => {\n    console.log(event, pickResult);\n  };\n\n\n};\n\n\n\n</script>","<template>\n  <NuxtLink v-show=\"path === '/'\" class=\"link link--about\" to=\"/about\">about</NuxtLink>\n  <NuxtLink v-show=\"path === '/'\" class=\"link link--insta\" to=\"/insta\">insta</NuxtLink>\n  <NuxtLink v-show=\"path !== '/'\" class=\"link link--home\" to=\"/\">x</NuxtLink>\n  <div class=\"content\">\n    <slot />\n  </div>\n  <Babylon />\n</template>\n\n<script setup>\n\nconst route = useRoute();\nconst path = ref(route.path)\n\nwatch(route, (r) => {\n  path.value = r.path\n})\n</script>\n\n<style lang=\"scss\">\n$padding-inline: 25%;\n$padding-block: 10%;\n\nbody {\n  margin: 0;\n}\n\n.content {\n  background: rgba(1, 0, 0, 0.8);\n  color: white;\n  position: absolute;\n  left: $padding-inline;\n  right: $padding-inline;\n  top: $padding-block;\n  bottom: $padding-block;\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n  height: fit-content;\n  overflow: scroll;\n  max-height: 100%;\n  pointer-events: all;\n}\n\n.link {\n  height: fit-content;\n  background: white;\n  position: absolute;\n\n  &--about {\n    top: $padding-block;\n    left: $padding-inline;\n  }\n\n  &--insta {\n    top: $padding-block;\n    right: $padding-inline;\n  }\n\n  &--home {\n    top: $padding-block;\n    right: $padding-inline;\n    z-index: 1;\n  }\n}\n</style>"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AA6BA,gBAAA,eAAA,IAAA,eAAA;AAIA,UAAA,YAAA,IAAA,IAAA;AAwBA,UAAA,iBAAA,MAAA;AACA,gBAAA,MAAA,QAAA,OAAA;AACA,gBAAA,MAAA,SAAA,OAAA;AAAA,IAEA;AAEA,UAAA,UAAA,MAAA;AACA,aAAA,oBAAA,UAAA,cAAA;AAAA,IACA;AAEA,gBAAA,MAAA;AACA;IACA,CAAA;;;;;;;;;;;;;;;;;;;;;;ACzDA,UAAA,QAAA,SAAA;AACA,UAAA,OAAA,IAAA,MAAA,IAAA;AAEA,UAAA,OAAA,CAAA,MAAA;AACA,WAAA,QAAA,EAAA;AAAA,IACA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;"}